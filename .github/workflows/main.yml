name: Privy Signing Service CI/CD Pipeline

on: 
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup SSH with passphrase
      env:
        SSH_KEY: ${{ secrets.SSH_KEY }}
        SSH_KEY_PHRASE: ${{ secrets.SSH_KEY_PHRASE }}
      run: |
        # Устанавливаем expect для работы с passphrase
        sudo apt-get update -qq
        sudo apt-get install -y expect
        
        # Создаем директорию для SSH
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Сохраняем приватный ключ (правильно обрабатываем многострочный текст)
        printf '%s\n' "$SSH_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        # Проверяем, что ключ создан
        if [ ! -f ~/.ssh/deploy_key ]; then
          echo "ERROR: Failed to create SSH key file"
          exit 1
        fi
        
        echo "SSH key file created successfully"
        ls -la ~/.ssh/deploy_key
        
        # Запускаем ssh-agent
        eval $(ssh-agent -s)
        
        # Получаем абсолютный путь к ключу
        KEY_PATH="${HOME}/.ssh/deploy_key"
        echo "Using key path: ${KEY_PATH}"
        
        # Проверяем длину passphrase (без вывода самого пароля)
        PHRASE_LENGTH=${#SSH_KEY_PHRASE}
        echo "Passphrase length: ${PHRASE_LENGTH} characters"
        
        # Сохраняем passphrase во временный файл (используем printf для безопасности)
        PASSPHRASE_FILE=$(mktemp)
        printf '%s' "$SSH_KEY_PHRASE" > "${PASSPHRASE_FILE}"
        chmod 600 "${PASSPHRASE_FILE}"
        
        # Создаем expect скрипт в отдельном файле для лучшей обработки спецсимволов
        EXPECT_SCRIPT=$(mktemp)
        cat > "${EXPECT_SCRIPT}" << 'EXPECT_END'
        #!/usr/bin/expect -f
        set timeout 10
        set key_path [lindex $argv 0]
        set pass_file [lindex $argv 1]
        
        # Читаем passphrase из файла
        set fp [open $pass_file r]
        set passphrase [read $fp]
        close $fp
        
        spawn ssh-add $key_path
        expect {
          "Enter passphrase*" {
            send -- "$passphrase\r"
            expect {
              "Identity added*" {
                puts "✅ SSH key added successfully"
                exit 0
              }
              "Bad passphrase*" {
                puts "❌ ERROR: Bad passphrase - please check SSH_KEY_PHRASE secret"
                exit 1
              }
              timeout {
                puts "❌ ERROR: Timeout waiting for confirmation"
                exit 1
              }
            }
          }
          timeout {
            puts "❌ ERROR: Timeout waiting for passphrase prompt"
            exit 1
          }
        }
        EXPECT_END
        
        chmod +x "${EXPECT_SCRIPT}"
        
        # Запускаем expect скрипт с аргументами
        "${EXPECT_SCRIPT}" "${KEY_PATH}" "${PASSPHRASE_FILE}"
        
        # Удаляем временные файлы
        rm -f "${PASSPHRASE_FILE}" "${EXPECT_SCRIPT}"
        
        # Проверяем, что ключ добавлен (показываем только отпечаток, не сам ключ)
        echo "Keys in ssh-agent:"
        ssh-add -l
        
        echo ""
        echo "=========================================="
        echo "Public key for server authorization:"
        echo "=========================================="
        ssh-add -L
        echo "=========================================="
        echo ""
        echo "⚠️  IMPORTANT: Make sure this public key is added to the server!"
        echo "On the server, run:"
        echo "  mkdir -p ~/.ssh"
        echo "  echo '<public_key_above>' >> ~/.ssh/authorized_keys"
        echo "  chmod 700 ~/.ssh"
        echo "  chmod 600 ~/.ssh/authorized_keys"
        echo ""
        
        # Очищаем временные файлы с чувствительными данными
        rm -f ~/.ssh/deploy_key
        
        # Добавляем сервер в known_hosts
        ssh-keyscan -p ${{ secrets.PORT }} ${{ secrets.HOST }} >> ~/.ssh/known_hosts
        
        # Сохраняем переменные ssh-agent для последующих шагов
        echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
        echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV

    - name: Check Docker and Docker Compose access
      run: |
        # Проверяем, что ssh-agent доступен
        echo "SSH_AUTH_SOCK: $SSH_AUTH_SOCK"
        echo "SSH_AGENT_PID: $SSH_AGENT_PID"
        echo "Keys in ssh-agent:"
        ssh-add -l
        
        # Показываем публичный ключ для проверки
        echo ""
        echo "Public key that will be used for authentication:"
        ssh-add -L
        echo ""
        
        # Тестируем SSH подключение с verbose для диагностики
        echo "Testing SSH connection..."
        ssh -v -o StrictHostKeyChecking=no -o BatchMode=yes -p ${{ secrets.PORT }} ${{ secrets.USERNAME }}@${{ secrets.HOST }} 'echo "SSH connection successful!"' 2>&1 | grep -E "(Offering|Authentications|publickey|Permission)" || true
        
        # Подключаемся к серверу
        ssh -o StrictHostKeyChecking=no -o BatchMode=yes -p ${{ secrets.PORT }} ${{ secrets.USERNAME }}@${{ secrets.HOST }} << 'EOF'
          # Проверяем доступ к Docker
          if ! docker --version &>/dev/null; then
            echo "ERROR: Deploy user cannot access Docker"
            echo "Please ensure:"
            echo "1. Docker is installed on the server"
            echo "2. Deploy user is added to docker group: sudo usermod -aG docker deploy"
            echo "3. Docker service is running: sudo systemctl start docker"
            exit 1
          fi
          
          if ! docker compose version &>/dev/null; then
            echo "ERROR: Deploy user cannot access Docker Compose"
            echo "Please ensure Docker Compose is installed and accessible"
            exit 1
          fi
          
          echo "✅ Docker access verified for deploy user"
          echo "Docker version: $(docker --version)"
          echo "Docker Compose version: $(docker compose version)"
        EOF

    - name: Deploy Privy Signing Service
      run: |
        # Подключаемся к серверу для деплоя
        ssh -o StrictHostKeyChecking=no -p ${{ secrets.PORT }} ${{ secrets.USERNAME }}@${{ secrets.HOST }} << 'EOF'
          # Создаем директорию если она не существует
          sudo mkdir -p /opt/polycopy/
          sudo chown $(whoami):$(whoami) /opt/polycopy/
          cd /opt/polycopy/
          
          echo "Current working directory: $(pwd)"
          echo "User: $(whoami)"
          echo "Groups: $(groups)"
          
          if [ -d "privy-signing/.git" ]; then
            echo "Repository exists, pulling latest changes..."
            cd privy-signing
            
            # Настраиваем git для использования PAT
            git config credential.helper store
            echo "https://${{ secrets.GPAT }}:x-oauth-basic@github.com" > ~/.git-credentials
            
            git fetch origin
            git pull origin main
          else
            echo "Cloning repository..."
            
            # Проверяем, что токен установлен
            if [ -z "${{ secrets.GPAT }}" ]; then
              echo "ERROR: GPAT secret is not set!"
              exit 1
            fi
            
            # Клонируем репозиторий с PAT токеном
            if git clone https://${{ secrets.GPAT }}:x-oauth-basic@github.com/TaroHarado/polycopy-privy-signing.git privy-signing; then
              echo "Clone successful"
            else
              echo "Clone failed"
              exit 1
            fi
            
            cd privy-signing
            
            # Настраиваем git для будущих операций
            git config credential.helper store
            echo "https://${{ secrets.GPAT }}:x-oauth-basic@github.com" > ~/.git-credentials
          fi
          
          # Проверяем существование файлов
          if [ -f "deploy.sh" ]; then
            chmod +x deploy.sh
            echo "deploy.sh found and made executable"
          else
            echo "Error: deploy.sh not found"
            ls -la
            exit 1
          fi
          
          # Делаем исполняемыми startup скрипты
          if [ -d "startup_scripts" ]; then
            chmod +x startup_scripts/entrypoint.sh
            chmod +x startup_scripts/wait-for-it.sh
            echo "Startup scripts made executable"
          fi

          # Настраиваем переменные среды для деплоя
          export GITHUB_ACTIONS=true
          export CI=true

          # Запускаем deploy.sh
          echo "Starting deployment..."
          ./deploy.sh
        EOF
